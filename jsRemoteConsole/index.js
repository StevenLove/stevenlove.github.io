'use strict';
/* 
  This is code for the server at jsconsole.net.
  It manages WebSocket connections to browsers and forwards messages from some 
  browsers (broadcasters) to other browsers (listeners)
  The intent is to broadcast from a browser where you can't see console.log messages
  to another browser where you can see them.
*/
const LOCAL_PORT = 5002;
const PORT = process.env.PORT || LOCAL_PORT;

/* Import libraries */
let express = require('express');
let bodyParser = require('body-parser');
let WSServer = require('ws').Server;
let server = require('http').createServer();

/* Initialize http server */
let app = express();
app.use(bodyParser.json());
app.use(express.static('public'))
server.on('request', app); // send requests to handlers in the http-server.js file
server.listen(PORT, function() { // listen on the proper port
  console.log(`http/ws server listening on ${PORT}`);
});

/* Initialize WebSockets server on top of http server */
let wss = new WSServer({server: server});
console.log("server established");

/* Keep track of ongoing connections */
let listeners = {};
let broadcasters = {};
let chains = {}; // which sessions have at least one listener and at least one broadcaster
let numMessages = 0;

wss.on('connection', function connection(ws) {
  let role;
  let myID;

  /* When a new WebSocket connects to the server, we have to figure out...
  1. what role the socket is playing and (listener or broadcaster)
  2. what ID to associate the socket with.
  This helps us determine where to send each individual log message */
  function setRole(newRole){
    role = newRole;
    if(myID && role)finishHandshake();
  }
  function setID(newID){
    myID = newID;
    if(myID && role)finishHandshake();
  }
  function finishHandshake(){
    let roleMap;
    if(role=="broadcaster"){
      roleMap = broadcasters;
    }
    else if(role=="listener"){
      roleMap = listeners;
    }
    else{
      console.error("invalid role",role,id);
      return;
    }
    /* Handle a new connection being created */
    roleMap[myID] = roleMap[myID] || []; // If it doesn't yet exist, make it an array
    roleMap[myID].push(ws);
    if(!chains[myID] && isChainFormed()){ // If this newly creates a chain
      chains[myID] = true;
      broadcast("cYour app has been connected for remote debugging!");
    }
    else if(isChainFormed()){ // already chained, but a new member added
      displayConnections();
    }
    else{// no chain yet formed, no need to print anything
      
    }
    logConnections();
    /* Now to handle what happens when an existing connection is severed */
    ws.on("close",()=>{
      roleMap[myID] = roleMap[myID].filter(socket=>socket != ws);
      if(roleMap[myID].length < 1){
        delete roleMap[myID];
      }
      if(chains[myID] && !isChainFormed()){ // if this breaks a chain
        chains[myID] = false;
        broadcast("oYour remote page has been disconnected from the server");
      }
      else{
        displayConnections();
      }
      logConnections();
    })

  }
  /* Parsing a message received from include.js or index.html...
  messages are 'encoded' such that the very first character determines
  the nature of the message, and the rest of the characters are the message.
  So we extract that first character to determine how to react */
  ws.on('message', function incoming(message) {
    let firstChar = message.charAt(0);
    let rest = message.slice(1);
    /* role */
    if(firstChar == 'r'){
      setRole(rest);
    }
    /* id */
    if(firstChar == 'd'){
      setID(rest);
    }
    /* console.log, .warn, .error, .info */
    if(firstChar == 'l' || firstChar == 'w' || firstChar == 'e' || firstChar == 'i'){
      ++numMessages;
      broadcast(message); // forward the whole 
    }
    /* internal comments or errors generated by this server rather than the console message sent from a broadcaster */
    if(firstChar == 'c' || firstChar == 'o'){
      broadcast(message);
    }
    /* keepalive */
    if(firstChar == 'k'){
      // don't do anything, just a keepalive
    }
  });

  function isChainFormed(){
    return listeners[myID] && broadcasters[myID];
  }
  function logConnections(){
    let ids = {};
    Object.keys(listeners).forEach(id=>ids[id]=true);
    Object.keys(broadcasters).forEach(id=>ids[id]=true);
    Object.keys(ids).forEach(id=>{
      console.log(id,":",numBroadcasters(id),"broadcasters. ",numListeners(id),"listeners.");
    })
    console.log("total messages sent",numMessages);
    console.log("---");
  }
  function displayConnections(){
    let nb = numBroadcasters(myID);
    let nl = numListeners(myID);
    let bcString = (nb == 1)?"1 broadcaster":nb+" broadcasters";
    let lsString = (nl == 1)?"1 listener":nl+" listeners";
    broadcast("cNumber of connections: "+bcString+" and "+lsString+".");
  }
  function broadcast(message){
    let targets = listeners[myID];
      if(targets){
        targets.forEach(target=>{
          target.send(message);
        })
      }
      else{
        console.log("targets not found",myID,message);
      }
  }
});

function numBroadcasters(id){
  return broadcasters[id]? broadcasters[id].length : 0;
}
function numListeners(id){
  return listeners[id]? listeners[id].length : 0;
}
